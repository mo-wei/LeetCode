# 2023å¹´4æœˆåˆ·é¢˜æŠ¥å‘Š

## 4æœˆ6æ—¥ï¼š

### ä»ä¸­åºå’Œååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘M

==äºŒå‰æ ‘çš„éå†å’Œæ„é€ ==

[106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return myBuildTree(postorder,0,postorder.size(),inorder, 0, inorder.size());
    }
    TreeNode* myBuildTree(vector<int>& postorder, int post_start, int post_end, vector<int>& inorder, int in_start, int in_end)
    {
        if(post_end == post_start) return nullptr;
        int root_val = postorder[post_end-1];
        TreeNode* root = new TreeNode(root_val);
        int root_index = 0;
        for(int i = 0; i < in_end ; i++){
            if(inorder[i] == root_val){
                root_index = i;
                break;
            }
        }
        int left_num = root_index - in_start;
        root->left = myBuildTree(postorder,post_start,post_start+left_num,inorder,in_start, root_index);
        root->right = myBuildTree(postorder,post_start+left_num,post_end - 1,inorder,root_index + 1, in_end);
        return root;
    }
};
```

**æœ¬é¢˜æ€è·¯ï¼š**

1ã€æ ¸å¿ƒè¿˜æ˜¯ç”¨ååºæ‰¾æ ¹ï¼Œä¸­åºåˆ†ä¸¤åŠ

2ã€ç”¨åˆ°é€’å½’çš„é¢˜ç›®ï¼Œé€»è¾‘åŸºæœ¬å¾ˆå°‘å‡ºé”™ï¼Œä½†**é€’å½’æ¡ä»¶å¾ˆç»å¸¸å‡ºé”™**ï¼Œä¸€å®šè¦æ³¨æ„è¾¹ç•Œ

## 4æœˆ7æ—¥ï¼š

### äºŒå‰æ ‘çš„å±‚åºéå† IIM

==äºŒå‰æ ‘çš„éå†==

//æ—¶é—´å‡»è´¥ç™¾åˆ†ä¹‹ä¸ƒåï¼Œå†…å­˜åªå‡»è´¥ç™¾åˆ†ä¹‹ä¸ƒğŸ¤£ï¼ŒåŠ æ²¹å§

[107. äºŒå‰æ ‘çš„å±‚åºéå† II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

```c++
class Solution {
public:
    vector<vector<int>> levels;
    int maxdepth = -1;
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> result;
        Sequence(root,0);
        for(int i = levels.size() - 1; i >= 0; i--)
        {
            result.push_back(levels[i]);
        }
        return result;
    }
    void Sequence(TreeNode *&root, int depth)
    {
        if(root == nullptr) return;
        if(maxdepth < depth)
        {
            vector<int> temp;
            levels.push_back(temp);
            maxdepth = depth;
        }
        levels[depth].push_back(root->val);
        Sequence(root->left, depth + 1);
        Sequence(root->right, depth + 1);
    }
};
```

**æœ¬é¢˜æ€è·¯ï¼š**

1ã€æ ¸å¿ƒè¿˜æ˜¯é€’å½’éå†ï¼Œè¿™é‡Œç”¨çš„å‰åºéå†(è¿™æ ·å¯ä»¥ä¿è¯æ¯ä¸€å±‚çš„æ•°æ®å…ˆåæ˜¯æ­£ç¡®çš„)

2ã€æ¯åˆ°æ–°çš„ä¸€å±‚å¢åŠ ä¸€ä¸ªvector\<int\>ï¼Œç„¶åæŒ‰æ·±åº¦æ”¾è¿›æŒ‡å®šçš„vectorï¼Œæœ€åå†å€’åºvector\<int\>å°±è¡Œ


## 4æœˆ10æ—¥ï¼š

### å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘E

==å¹³è¡¡äºŒå‰æ ‘çš„æ„å»º==

[108.å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)


```c++
class Solution {
public:
    TreeNode* mySortedArrayToBST(vector<int>& nums, int left, int right)
    {
        if(left >= right) return nullptr;
        int mid = (right + left)/2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = mySortedArrayToBST(nums,left,mid);
        root->right = mySortedArrayToBST(nums,mid+1,right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return mySortedArrayToBST(nums,0,nums.size());
    }
};
```

**æœ¬é¢˜æ€è·¯ï¼š**

1ã€è¿™é¢˜çœ‹ä¼¼è¦ç”¨æ—‹è½¬ç­‰æ–¹å¼æ„å»ºäºŒå¹³è¡¡äºŒå‰æ ‘ï¼Œä½†é¢˜ç›®æ•°ç»„å·²ç»æ˜¯å‡åºï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ç”¨æœ€åº•å±‚çš„çŸ¥è¯†ï¼Œå¯¹åŠå¼€å°±ä¸€å®šæ˜¯å¹³è¡¡çš„ï¼Œå› ä¸ºå·¦å³å­æ ‘æ•°é‡åŸºæœ¬ä¸€ç›´ï¼Œä¸å¯èƒ½ä¸å¹³è¡¡

## 4æœˆ17æ—¥ï¼š

### æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘M

==å¹³è¡¡äºŒå‰æ ‘çš„æ„å»º==

[109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)

```c++
classÂ SolutionÂ {
public:
Â Â Â Â TreeNode*Â sortedListToBST(ListNode*Â head)Â {
Â Â Â Â Â Â Â Â TreeNode*Â root;Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if(!head)
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ nullptr;
Â Â Â Â Â Â Â Â if(!head->next){
Â Â Â Â Â Â Â Â Â Â Â Â rootÂ =Â newÂ TreeNode(head->val);
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ root;
Â Â Â Â Â Â Â Â }Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â ListNodeÂ *slowÂ =Â head;
Â Â Â Â Â Â Â Â ListNodeÂ *fastÂ =Â head;
Â Â Â Â Â Â Â Â ListNodeÂ *prevÂ =Â head;
Â Â Â Â Â Â Â Â while(fastÂ !=NULLÂ &&Â fast->nextÂ !=NULL){
Â Â Â Â Â Â Â Â Â Â Â Â fastÂ =Â fast->next->next;
Â Â Â Â Â Â Â Â Â Â Â Â slowÂ =Â slow->next;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â while(prev->nextÂ !=Â slow)
Â Â Â Â Â Â Â Â Â Â Â Â prevÂ =Â prev->next;Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â rootÂ =Â newÂ TreeNode(slow->val);
Â Â Â Â Â Â Â Â ListNode*Â headRightÂ =Â slow->next;
Â Â Â Â Â Â Â Â prev->nextÂ =Â nullptr;
Â Â Â Â Â Â Â Â root->leftÂ =Â sortedListToBST(head);
Â Â Â Â Â Â Â Â root->rightÂ =Â sortedListToBST(headRight);
Â Â Â Â Â Â Â Â returnÂ root;
Â Â Â Â }Â 
};
```

**æœ¬é¢˜æ€è·¯ï¼š**

1ã€é“¾è¡¨æ‰¾ä¸­é—´ç»“ç‚¹å¯ä»¥ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œè¿™å¾ˆé‡è¦ï¼Œæ‰¾åˆ°ä¸­é—´ç»“ç‚¹ï¼Œå…¶ä»–æ€è·¯åŸºæœ¬ä¸æ•°ç»„æ„å»ºç›¸ä¼¼


## 4æœˆ18æ—¥

### å¹³è¡¡äºŒå‰æ ‘E

==åˆ¤æ–­å¹³è¡¡äºŒå‰æ ‘==

[110. å¹³è¡¡äºŒå‰æ ‘](https://leetcode.cn/problems/balanced-binary-tree/)
```c++
classÂ SolutionÂ {
public:
Â Â Â Â boolÂ isBalanced(TreeNode*Â root)Â {
Â Â Â Â Â Â Â Â returnÂ height(root)Â >=0;
Â Â Â Â }
Â Â Â Â intÂ height(TreeNode*Â root){
Â Â Â Â Â Â Â Â if(rootÂ ==Â nullptr){
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ 0;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â intÂ lhÂ =Â height(root->left),rhÂ =Â height(root->right);
Â Â Â Â Â Â Â Â if(lhÂ >=Â 0Â &&Â rhÂ >=Â 0Â &&Â abs(lhÂ -Â rh)Â <=Â 1){
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ max(lh,rh)Â +Â 1;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â else{
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ -1;
Â Â Â Â Â Â Â Â }
Â Â Â Â }
};
```
**æœ¬é¢˜æ€è·¯**ï¼›
1ã€æ¯ä¸ªç»“ç‚¹éƒ½éœ€è¦è·å¾—å·¦å³å­æ ‘é«˜åº¦ï¼Œç„¶ååŠæ—¶åˆ¤æ–­å·®å€¼æ˜¯å¦å¤§äº1
2ã€==è¿™ä¸ªè§£æ³•ç›¸å½“å·§å¦™ï¼Œå¯ä»¥é‡ç‚¹è®°ä½æ­¤å†™æ³•==

## 4æœˆ19æ—¥

### äºŒå‰æ ‘çš„æœ€å°æ·±åº¦E

==äºŒå‰æ ‘çš„æœ€å°æ·±åº¦==

[111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```c++
classÂ SolutionÂ {
public:
Â Â Â Â intÂ minDepth(TreeNode*Â root)Â {
Â Â Â Â Â Â Â Â returnÂ min_height(root);
Â Â Â Â }
Â Â Â Â intÂ min_height(TreeNode*Â root)
Â Â Â Â {
Â Â Â Â Â Â Â Â if(rootÂ ==Â nullptr){
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ 0;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â intÂ lmin_heightÂ =Â min_height(root->left);
Â Â Â Â Â Â Â Â intÂ rmin_heightÂ =Â min_height(root->right);
Â Â Â Â Â Â Â Â if(lmin_heightÂ >Â 0Â &&Â rmin_heightÂ >Â 0){
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ min(lmin_height,rmin_height)Â +Â 1;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â else{
	Â Â Â Â Â Â Â Â return lmin_height + rmin_height + 1;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â /*ã€elseÂ if(rmin_heightÂ ==Â 0){
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ lmin_heightÂ +Â 1;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â else{
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ rmin_heightÂ +Â 1;
Â Â Â Â Â Â Â Â }*/
Â Â Â Â }
};

```

**æœ¬é¢˜æ€è·¯**ï¼š
1ã€ä»ä¸Šä¸€é¢˜ä¸­è·å¾—çš„æ€è·¯ï¼Œåˆ†åˆ«é€’å½’è®¡ç®—å·¦å³ï¼Œä¸¤è€…éƒ½æœ‰å­æ ‘çš„æ—¶å€™å–è¾ƒå°å€¼ï¼Œåªæœ‰ä¸€ä¸ªæœ‰çš„æ—¶å€™å–ä¸¤è€…ä¹‹å’Œ + 1(å› ä¸ºå¿…æœ‰ä¸€ä¸ªæ˜¯0ï¼Œå¯ä»¥å‡å°‘åˆ¤æ–­åˆ†æ”¯)

## 4æœˆ20æ—¥

### è·¯å¾„æ€»å’ŒE

==äºŒå‰æ ‘éå†==

[112. è·¯å¾„æ€»å’Œ](https://leetcode.cn/problems/path-sum/)

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        return myHasPathSum(root,targetSum,0);
    }
    bool myHasPathSum(TreeNode* root, int targetSum, int currentSum)
    {
        if(root == nullptr) return false;
        if(root->left == nullptr && root->right == nullptr){
            return currentSum + root->val == targetSum;
        }
        return myHasPathSum(root->left,targetSum,currentSum + root->val) || 
        myHasPathSum(root->right,targetSum,currentSum + root->val);
    }
};
```

**æœ¬ä½“æ€è·¯**ï¼š
1ã€è¿™ä¸ªè§£æ³•å½“æ—¶å†™çš„æ—¶å€™ï¼Œè¿˜æ˜¯è‡ªå·±å»ºäº†ä¸€ä¸ªéå†å‡½æ•°ï¼Œç”¨ä¸€ä¸ªå‚æ•°è®°å½•å½“å‰çš„è·¯å¾„ä¹‹å’Œ(==å…¶å®å¯ä»¥åœ¨ä¸€ä¸ªå‡½æ•°ï¼Œç„¶åç”¨å‡æ³•ï¼Œçœ‹æ˜¯å¦å‡åˆ°0==)

*è¡¥å……è§£æ³•*

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return false;
        }
        if (root->left == nullptr && root->right == nullptr) {
            return targetSum - root->val == 0;
        }
        return hasPathSum(root->left, targetSum - root->val)
                || hasPathSum(root->right, targetSum - root->val);
    }
};
```

**æœ¬é¢˜æ€è·¯**
1ã€å“ˆå“ˆå“ˆï¼Œæ€è·¯å±…ç„¶å’Œå¤§ä½¬çš„å¤§å·®ä¸å·®ï¼Œä½†æ˜¯ä»¥åè¿˜æ˜¯æ³¨æ„çœ‹çœ‹èƒ½å¦åœ¨é¢˜ç›®å‡½æ•°ä¸­é€’å½’ï¼Œè‡ªå·±å¼€ä¸€ä¸ªå‡½æ•°è¿˜æ˜¯è¦æ…¢äº†ä¸€ç‚¹

## 4æœˆ21æ—¥

### è·¯å¾„æ€»å’Œ IIM

==äºŒå‰æ ‘éå†==

[113. è·¯å¾„æ€»å’Œ II](https://leetcode.cn/problems/path-sum-ii/)

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> temp;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        myPathSum(root,targetSum);
        return result;
    }
    void myPathSum(TreeNode* root,int targetSum){
        if (root == nullptr) {
            return;
        }
        temp.push_back(root->val);
        if (root->left == nullptr && root->right == nullptr) {
            if(targetSum - root->val == 0){
                result.push_back(temp);
                return;
            }
        }
        myPathSum(root->left, targetSum - root->val);
        if(root->left)temp.pop_back();
        myPathSum(root->right, targetSum - root->val);
        if(root->right)temp.pop_back();
    }
};
```

**æœ¬é¢˜æ€è·¯**ï¼š
1ã€ä¸Šä¸€é¢˜çš„å»¶ç”³ï¼Œåšä¸Šä¸€é¢˜çš„æ—¶å€™æˆ‘å°±çŸ¥é“åä¸€é¢˜éœ€è¦æŠŠæ‰€æœ‰å€¼ç»Ÿè®¡å‡ºæ¥ï¼Œå…¶å®å°±æ˜¯æ‰¾åˆ°æ­£ç¡®çš„ä»£ç è·¯å¾„ï¼ŒæŠŠpush_backå’Œpop_backå¡«å…¥å°±è¡Œ

## 4æœˆ24æ—¥

### äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨M

==äºŒå‰æ ‘éå†==

[114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

```c++
class Solution {
public:
    TreeNode* last;    
    void flatten(TreeNode* root) {
        if(root == nullptr) return;
        flatten(root->right);
        flatten(root->left);
        root->right = last;
        root->left = nullptr;
        last = root;
    }
};
```

**æœ¬é¢˜æ€è·¯**ï¼š
1ã€ä»å‰å¾€åè°ƒç”¨ä¼šç¨å¾®éš¾æ“ä½œä¸€ç‚¹ï¼Œä»åå¾€å‰å°±å¥½ä¸€ç‚¹ï¼Œ**é€†å‘æ€ç»´å¾ˆé‡è¦**ï¼Œæ¢ä¸ªè§’åº¦æ€è€ƒä¼šç®€å•å¾ˆå¤š

## 4æœˆ26æ—¥ï¼š

### ä¸‰è§’å½¢æœ€å°è·¯å¾„å’ŒM

==åŠ¨æ€è§„åˆ’==

[120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ](https://leetcode.cn/problems/triangle/)

```c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        for(int i = triangle.size() - 2;i >= 0; i--)
            for(int j = 0; j < triangle[i].size();j++)
            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);
        return triangle[0][0];
    }
};
```

**æœ¬é¢˜æ€è·¯**ï¼š
1ã€æ²¡æƒ³åˆ°è¿™é¢˜å±…ç„¶æ˜¯åŠ¨æ€è§„åˆ’å…¥é—¨é¢˜äº†ï¼Œåˆæ˜¯ä¸€ä¸ªé€†å‘æ€ç»´ï¼Œä»åå¾€å‰ï¼Œä¸€æ¬¡é€‰æ‹©åå°çš„ç›¸åŠ ï¼Œæœ€ç»ˆè¿”å›æœ€ä¸Šå±‚å°±å¯ä»¥äº†