# 2023å¹´4æœˆåˆ·é¢˜æŠ¥å‘Š

## 4æœˆ6æ—¥ï¼š

### ä»ä¸­åºå’Œååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘M

==äºŒå‰æ ‘çš„éå†å’Œæ„é€ ==

[106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return myBuildTree(postorder,0,postorder.size(),inorder, 0, inorder.size());
    }
    TreeNode* myBuildTree(vector<int>& postorder, int post_start, int post_end, vector<int>& inorder, int in_start, int in_end)
    {
        if(post_end == post_start) return nullptr;
        int root_val = postorder[post_end-1];
        TreeNode* root = new TreeNode(root_val);
        int root_index = 0;
        for(int i = 0; i < in_end ; i++){
            if(inorder[i] == root_val){
                root_index = i;
                break;
            }
        }
        int left_num = root_index - in_start;
        root->left = myBuildTree(postorder,post_start,post_start+left_num,inorder,in_start, root_index);
        root->right = myBuildTree(postorder,post_start+left_num,post_end - 1,inorder,root_index + 1, in_end);
        return root;
    }
};
```

**æœ¬é¢˜æ€è·¯ï¼š**

1ã€æ ¸å¿ƒè¿˜æ˜¯ç”¨ååºæ‰¾æ ¹ï¼Œä¸­åºåˆ†ä¸¤åŠ

2ã€ç”¨åˆ°é€’å½’çš„é¢˜ç›®ï¼Œé€»è¾‘åŸºæœ¬å¾ˆå°‘å‡ºé”™ï¼Œä½†**é€’å½’æ¡ä»¶å¾ˆç»å¸¸å‡ºé”™**ï¼Œä¸€å®šè¦æ³¨æ„è¾¹ç•Œ

## 4æœˆ7æ—¥ï¼š

### äºŒå‰æ ‘çš„å±‚åºéå† IIM

==äºŒå‰æ ‘çš„éå†==

//æ—¶é—´å‡»è´¥ç™¾åˆ†ä¹‹ä¸ƒåï¼Œå†…å­˜åªå‡»è´¥ç™¾åˆ†ä¹‹ä¸ƒğŸ¤£ï¼ŒåŠ æ²¹å§

[107. äºŒå‰æ ‘çš„å±‚åºéå† II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

```c++
class Solution {
public:
    vector<vector<int>> levels;
    int maxdepth = -1;
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> result;
        Sequence(root,0);
        for(int i = levels.size() - 1; i >= 0; i--)
        {
            result.push_back(levels[i]);
        }
        return result;
    }
    void Sequence(TreeNode *&root, int depth)
    {
        if(root == nullptr) return;
        if(maxdepth < depth)
        {
            vector<int> temp;
            levels.push_back(temp);
            maxdepth = depth;
        }
        levels[depth].push_back(root->val);
        Sequence(root->left, depth + 1);
        Sequence(root->right, depth + 1);
    }
};
```

**æœ¬é¢˜æ€è·¯ï¼š**

1ã€æ ¸å¿ƒè¿˜æ˜¯é€’å½’éå†ï¼Œè¿™é‡Œç”¨çš„å‰åºéå†(è¿™æ ·å¯ä»¥ä¿è¯æ¯ä¸€å±‚çš„æ•°æ®å…ˆåæ˜¯æ­£ç¡®çš„)

2ã€æ¯åˆ°æ–°çš„ä¸€å±‚å¢åŠ ä¸€ä¸ªvector\<int\>ï¼Œç„¶åæŒ‰æ·±åº¦æ”¾è¿›æŒ‡å®šçš„vectorï¼Œæœ€åå†å€’åºvector\<int\>å°±è¡Œ


## 4æœˆ10æ—¥ï¼š

### å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘E

==å¹³è¡¡äºŒå‰æ ‘çš„æ„å»º==

[108.å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)


```c++
class Solution {
public:
    TreeNode* mySortedArrayToBST(vector<int>& nums, int left, int right)
    {
        if(left >= right) return nullptr;
        int mid = (right + left)/2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = mySortedArrayToBST(nums,left,mid);
        root->right = mySortedArrayToBST(nums,mid+1,right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return mySortedArrayToBST(nums,0,nums.size());
    }
};
```

**æœ¬é¢˜æ€è·¯ï¼š**

1ã€è¿™é¢˜çœ‹ä¼¼è¦ç”¨æ—‹è½¬ç­‰æ–¹å¼æ„å»ºäºŒå¹³è¡¡äºŒå‰æ ‘ï¼Œä½†é¢˜ç›®æ•°ç»„å·²ç»æ˜¯å‡åºï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ç”¨æœ€åº•å±‚çš„çŸ¥è¯†ï¼Œå¯¹åŠå¼€å°±ä¸€å®šæ˜¯å¹³è¡¡çš„ï¼Œå› ä¸ºå·¦å³å­æ ‘æ•°é‡åŸºæœ¬ä¸€ç›´ï¼Œä¸å¯èƒ½ä¸å¹³è¡¡

## 4æœˆ17æ—¥ï¼š

### æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘M

==å¹³è¡¡äºŒå‰æ ‘çš„æ„å»º==

[109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)

```c++
classÂ SolutionÂ {
public:
Â Â Â Â TreeNode*Â sortedListToBST(ListNode*Â head)Â {
Â Â Â Â Â Â Â Â TreeNode*Â root;Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if(!head)
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ nullptr;
Â Â Â Â Â Â Â Â if(!head->next){
Â Â Â Â Â Â Â Â Â Â Â Â rootÂ =Â newÂ TreeNode(head->val);
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ root;
Â Â Â Â Â Â Â Â }Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â ListNodeÂ *slowÂ =Â head;
Â Â Â Â Â Â Â Â ListNodeÂ *fastÂ =Â head;
Â Â Â Â Â Â Â Â ListNodeÂ *prevÂ =Â head;
Â Â Â Â Â Â Â Â while(fastÂ !=NULLÂ &&Â fast->nextÂ !=NULL){
Â Â Â Â Â Â Â Â Â Â Â Â fastÂ =Â fast->next->next;
Â Â Â Â Â Â Â Â Â Â Â Â slowÂ =Â slow->next;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â while(prev->nextÂ !=Â slow)
Â Â Â Â Â Â Â Â Â Â Â Â prevÂ =Â prev->next;Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â rootÂ =Â newÂ TreeNode(slow->val);
Â Â Â Â Â Â Â Â ListNode*Â headRightÂ =Â slow->next;
Â Â Â Â Â Â Â Â prev->nextÂ =Â nullptr;
Â Â Â Â Â Â Â Â root->leftÂ =Â sortedListToBST(head);
Â Â Â Â Â Â Â Â root->rightÂ =Â sortedListToBST(headRight);
Â Â Â Â Â Â Â Â returnÂ root;
Â Â Â Â }Â 
};
```

**æœ¬é¢˜æ€è·¯ï¼š**

1ã€é“¾è¡¨æ‰¾ä¸­é—´ç»“ç‚¹å¯ä»¥ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œè¿™å¾ˆé‡è¦ï¼Œæ‰¾åˆ°ä¸­é—´ç»“ç‚¹ï¼Œå…¶ä»–æ€è·¯åŸºæœ¬ä¸æ•°ç»„æ„å»ºç›¸ä¼¼


## 4æœˆ18æ—¥
### å¹³è¡¡äºŒå‰æ ‘E

==åˆ¤æ–­å¹³è¡¡äºŒå‰æ ‘==

[110. å¹³è¡¡äºŒå‰æ ‘](https://leetcode.cn/problems/balanced-binary-tree/)
```c++
classÂ SolutionÂ {
public:
Â Â Â Â boolÂ isBalanced(TreeNode*Â root)Â {
Â Â Â Â Â Â Â Â returnÂ height(root)Â >=0;
Â Â Â Â }
Â Â Â Â intÂ height(TreeNode*Â root){
Â Â Â Â Â Â Â Â if(rootÂ ==Â nullptr){
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ 0;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â intÂ lhÂ =Â height(root->left),rhÂ =Â height(root->right);
Â Â Â Â Â Â Â Â if(lhÂ >=Â 0Â &&Â rhÂ >=Â 0Â &&Â abs(lhÂ -Â rh)Â <=Â 1){
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ max(lh,rh)Â +Â 1;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â else{
Â Â Â Â Â Â Â Â Â Â Â Â returnÂ -1;
Â Â Â Â Â Â Â Â }
Â Â Â Â }
};
```
**æœ¬é¢˜æ€è·¯**ï¼›
1ã€æ¯ä¸ªç»“ç‚¹éƒ½éœ€è¦è·å¾—å·¦å³å­æ ‘é«˜åº¦ï¼Œç„¶ååŠæ—¶åˆ¤æ–­å·®å€¼æ˜¯å¦å¤§äº1
2ã€==è¿™ä¸ªè§£æ³•ç›¸å½“å·§å¦™ï¼Œå¯ä»¥é‡ç‚¹è®°ä½æ­¤å†™æ³•==