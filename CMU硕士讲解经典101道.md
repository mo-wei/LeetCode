# 题目分类
![[picture/题型思维导图.png]]
三阶段：
1、算法
2、数学
3、数据结构

# 最易懂的贪心算法

==核心思想：每次操作都是局部最优的，从而使最后得到的结果是全局最优，局部结果互不相关时局部最优策略同样是全局最优==

## 分配问题

![[picture/455.png]]
[455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)
```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
            sort(g.begin(),g.end());
            sort(s.begin(),s.end());
            int childIndex = 0, cookieIndex = 0;
            int childCount = g.size(), cookieCount = s.size();
            while(childIndex < childCount && cookieIndex < cookieCount){
                if(g[childIndex]<= s[cookieIndex]){
                    childIndex++;
                }
                cookieIndex++;
            }
            return childIndex;
    }
```
**本题思路**：
1、饥饿度越小越容易吃饱，用尽量小的饼干去满足他，满足最终的最优解
> TIP：对数组排序是十分常见的，字符数组和字符串不需要特别区分，"abc"和[‘a’,'b','c']都是连续空间上的有序变量集合

![[picture/135.png]]
[135. 分发糖果](https://leetcode.cn/problems/candy/)
```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        // 从后向前
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] ) {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        // 统计结果
        int result = 0;
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
        return result;
    }
};
```
**本题思路**：
1、分配任务大多用贪心是可以很好解决的
2、左右开始各遍历一遍，左到右时直接比前一个加一，右到左时比后一个加一的值和当前已经赋值的最大值
3、最后所有值相加就行

## 区间问题
![[picture/435.png]]
[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)
```C++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        
        sort(intervals.begin(), intervals.end(), [](const auto& u, const auto& v) {
            return u[1] < v[1];
        });

        int n = intervals.size();
        int right = intervals[0][1];
        int ans = 0;
        for (int i = 1; i < n; ++i) {
            if (intervals[i][0] < right) {
                ++ans;
            }
            else{
                right = intervals[i][1];
            }
        }
        return ans;
    }
};
```
**本题思路**：
1、按段位大小排序，从头遍历，假如重叠，去掉段尾大的(贪心)\
2、补充：二元vector排序除了上面的写法还有下面写法
```c++
static bool compare(const vector<int>& v1,const vector<int>& v2) { //关于()元素的重载函数 
	return v1[1]<v2[1]; 
	}
	sort(intervals.begin(),intervals.end(),compare);
```
>**建议所有的返回类型都为static bool 类型,以避免出现不必要的bug!!!**
>建议在compare函数中形参加上**const**!!!

## 训练

[605. 种花问题](https://leetcode.cn/problems/can-place-flowers/)
![[picture/605.png]]
```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int index = 1;
        vector<int> my_flowerbed;
        my_flowerbed.push_back(0);
        my_flowerbed.insert(my_flowerbed.end(), flowerbed.begin(), flowerbed.end());
        my_flowerbed.push_back(0);
        int sz = my_flowerbed.size();
                while(index < sz - 1){
                if(my_flowerbed[index+1] == 0 && my_flowerbed[index-1] == 0 && my_flowerbed[index] == 0){
                    n--;
                    my_flowerbed[index] = 1;
                }
                index++;
        }
        cout << n;
        return n <= 0;
    }
};
```
**本题思路**
1、==防御式编程，数组左右两边加长，以避免边界判断==

[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)
![[picture/452.png]]
```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), [](vector<int>& a, vector<int>& b){
            return a[1] < b[1];
        });
        int prev = points[0][1];
        int size = points.size();
        int res = 1;
        for(int i = 1; i < size ; i++){
            if(points[i][0] > prev){
                res++;
                prev = points[i][1];
            }
        }
        return res;
    }
};
```
**本题思路**：
1. 和上面的435题异曲同工，==只是更新上一段末尾的时机不同==，不过自己做出来的感觉还是舒舒服服

[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)]
![[picture/763.png]]
```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int a[123] = {0};
        int sz = s.size();
        for(int i = 0; i < sz; i++){
            a[s[i]]++;//统计各个字符的数量
        }
        int index = 0;
        unordered_set<char> charSet;
        int charCount = 0;
        vector<int> res;
        int char_length = 0;
        while(index < sz){
            charSet.insert(s[index]);
            charCount = a[s[index]];
            char_length = 0;
            while(index < sz && charCount > 0){
                if(charSet.find(s[index]) == charSet.end()){//如果不存在
                    charSet.insert(s[index]);
                    charCount += a[s[index]];
                }
                charCount--;
                index++;
                char_length++;
            }
            res.push_back(char_length);
        }
        return res;
    }
};
```
**本题思路**
1、纯手撸出来还是有爽点的，这里使用了哈希统计频率，后续思路就比较清晰
2、其他解：==统计频率、个数、第一次出现位置、最后一次出现位置==
统计最后出现位置的话就类似于上面的区间问题了，及时更新最后位置分段
https://leetcode.cn/problems/partition-labels/comments/
评论第一写的是真的很漂亮

[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
![[picture/122.png]]
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        for(int i = 0; i < prices.size() - 1; i++){
            int temp = prices[i+1] - prices[i];
             if(temp > 0){
                profit += temp;
            }
        }
        return profit;
    }
};
```
**本题思路**：
1、因为同一天可以买卖，所以今天比明天价高就当天卖出，明天价高就明天卖掉

## 进阶训练

==进阶虽然难，但不能放掉，就算是读懂别人的题解，也能受益匪浅==

[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)、
*逆天题目，读题读半天*
![[picture/406.png]]
```c++
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), [](vector<int>& p1, vector<int>& p2){
            if(p1[0] == p2[0]){
                return p1[1] < p2[1];
            }
            else{
                return p1[0] > p2[0];
            }
        });
        vector<vector<int>> res;
        for(int i = 0, sz = people.size(); i < sz; i++){
            res.insert(res.begin()+people[i][1], people[i]);
        }
        return res;
    }
};
```
**本题思路**
1、题意解读：0号元素代表身高，1号元素代表排好队之后在它之前大于等于它身高的人数，
2、==小技巧：**一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。**==
3、排序技巧：sort函数真是十分的好用，不止是简单的一个语句，只要是可以正确比出两个元素，==可以加很多不同的分支，把多种比较情况在一个sort里写，简直是新世界啊==
4、回到题目本身，身高高的先放入，按自己的1号位的值就可以确定自己要插入的位置，相同身高1号位大的后插会更简单

[665. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/)
```c++
class Solution {
public:
    bool checkPossibility(vector<int>& nums) {
        vector<int> my_nums;
        my_nums.push_back(INT_MIN);
        my_nums.insert(my_nums.end(), nums.begin(), nums.end());
        my_nums.push_back(INT_MAX);
        int count = 0;
        for(int i = 1, sz = my_nums.size(); i < sz - 1; i++){
            if(my_nums[i] > my_nums[i+1]){
                    count++;
                    if(my_nums[i+1] < my_nums[i-1]){
                        my_nums[i+1] = my_nums[i];
                    }
                    else{
                        my_nums[i] = my_nums[i-1];
                    }
            }
            if(count == 2){
                return false;
            }
        }
        return true;
    }
};
```
**本题思路**
1、用了防御式编程
2、贪心的题目实在太靠归纳了，规律就是当my_nums[i] > my_nums[i+1]就进入，但更改的值还需要讨论，讨论的就是my_nums[i+1] < my_nums[i-1]，后一位和前一位的大小比较