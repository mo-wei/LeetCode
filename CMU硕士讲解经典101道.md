# 题目分类
![[picture/题型思维导图.png]]
三阶段：
1、算法
2、数学
3、数据结构

# 最易懂的贪心算法

==核心思想：每次操作都是局部最优的，从而使最后得到的结果是全局最优，局部结果互不相关时局部最优策略同样是全局最优==

## 分配问题

![[picture/455.png]]
[455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)
```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
            sort(g.begin(),g.end());
            sort(s.begin(),s.end());
            int childIndex = 0, cookieIndex = 0;
            int childCount = g.size(), cookieCount = s.size();
            while(childIndex < childCount && cookieIndex < cookieCount){
                if(g[childIndex]<= s[cookieIndex]){
                    childIndex++;
                }
                cookieIndex++;
            }
            return childIndex;
    }
```
**本题思路**：
1、饥饿度越小越容易吃饱，用尽量小的饼干去满足他，满足最终的最优解
> TIP：对数组排序是十分常见的，字符数组和字符串不需要特别区分，"abc"和[‘a’,'b','c']都是连续空间上的有序变量集合

![[picture/135.png]]
[135. 分发糖果](https://leetcode.cn/problems/candy/)
```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        // 从后向前
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] ) {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        // 统计结果
        int result = 0;
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
        return result;
    }
};
```
**本题思路**：
1、分配任务大多用贪心是可以很好解决的
2、左右开始各遍历一遍，左到右时直接比前一个加一，右到左时比后一个加一的值和当前已经赋值的最大值
3、最后所有值相加就行

## 区间问题
![[picture/435.png]]
[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)
```C++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        
        sort(intervals.begin(), intervals.end(), [](const auto& u, const auto& v) {
            return u[1] < v[1];
        });

        int n = intervals.size();
        int right = intervals[0][1];
        int ans = 0;
        for (int i = 1; i < n; ++i) {
            if (intervals[i][0] < right) {
                ++ans;
            }
            else{
                right = intervals[i][1];
            }
        }
        return ans;
    }
};
```
**本题思路**：
1、按段位大小排序，从头遍历，假如重叠，去掉段尾大的(贪心)\
2、补充：二元vector排序除了上面的写法还有下面写法
```c++
static bool compare(const vector<int>& v1,const vector<int>& v2) { //关于()元素的重载函数 
	return v1[1]<v2[1]; 
	}
	sort(intervals.begin(),intervals.end(),compare);
```
>**建议所有的返回类型都为static bool 类型,以避免出现不必要的bug!!!**
>建议在compare函数中形参加上**const**!!!

## 训练

[605. 种花问题](https://leetcode.cn/problems/can-place-flowers/)
![[picture/605.png]]
```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int index = 1;
        vector<int> my_flowerbed;
        my_flowerbed.push_back(0);
        my_flowerbed.insert(my_flowerbed.end(), flowerbed.begin(), flowerbed.end());
        my_flowerbed.push_back(0);
        int sz = my_flowerbed.size();
                while(index < sz - 1){
                if(my_flowerbed[index+1] == 0 && my_flowerbed[index-1] == 0 && my_flowerbed[index] == 0){
                    n--;
                    my_flowerbed[index] = 1;
                }
                index++;
        }
        cout << n;
        return n <= 0;
    }
};
```
**本题思路**
1、==防御式编程，数组左右两边加长，以避免边界判断==

[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)
![[picture/452.png]]
```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), [](vector<int>& a, vector<int>& b){
            return a[1] < b[1];
        });
        int prev = points[0][1];
        int size = points.size();
        int res = 1;
        for(int i = 1; i < size ; i++){
            if(points[i][0] > prev){
                res++;
                prev = points[i][1];
            }
        }
        return res;
    }
};
```
**本题思路**：
1. 和上面的435题异曲同工，==只是更新上一段末尾的时机不同==，不过自己做出来的感觉还是舒舒服服

[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)]
![[picture/763.png]]
```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int a[123] = {0};
        int sz = s.size();
        for(int i = 0; i < sz; i++){
            a[s[i]]++;//统计各个字符的数量
        }
        int index = 0;
        unordered_set<char> charSet;
        int charCount = 0;
        vector<int> res;
        int char_length = 0;
        while(index < sz){
            charSet.insert(s[index]);
            charCount = a[s[index]];
            char_length = 0;
            while(index < sz && charCount > 0){
                if(charSet.find(s[index]) == charSet.end()){//如果不存在
                    charSet.insert(s[index]);
                    charCount += a[s[index]];
                }
                charCount--;
                index++;
                char_length++;
            }
            res.push_back(char_length);
        }
        return res;
    }
};
```
**本题思路**
1、纯手撸出来还是有爽点的，这里使用了哈希统计频率，后续思路就比较清晰
2、其他解：==统计频率、个数、第一次出现位置、最后一次出现位置==
统计最后出现位置的话就类似于上面的区间问题了，及时更新最后位置分段
https://leetcode.cn/problems/partition-labels/comments/
评论第一写的是真的很漂亮

[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
![[picture/122.png]]
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        for(int i = 0; i < prices.size() - 1; i++){
            int temp = prices[i+1] - prices[i];
             if(temp > 0){
                profit += temp;
            }
        }
        return profit;
    }
};
```
**本题思路**：
1、因为同一天可以买卖，所以今天比明天价高就当天卖出，明天价高就明天卖掉

## 进阶训练

==进阶虽然难，但不能放掉，就算是读懂别人的题解，也能受益匪浅==

[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)、
*逆天题目，读题读半天*
![[picture/406.png]]
```c++
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), [](vector<int>& p1, vector<int>& p2){
            if(p1[0] == p2[0]){
                return p1[1] < p2[1];
            }
            else{
                return p1[0] > p2[0];
            }
        });
        vector<vector<int>> res;
        for(int i = 0, sz = people.size(); i < sz; i++){
            res.insert(res.begin()+people[i][1], people[i]);
        }
        return res;
    }
};
```
**本题思路**
1、题意解读：0号元素代表身高，1号元素代表排好队之后在它之前大于等于它身高的人数，
2、==小技巧：**一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。**==
3、排序技巧：sort函数真是十分的好用，不止是简单的一个语句，只要是可以正确比出两个元素，==可以加很多不同的分支，把多种比较情况在一个sort里写，简直是新世界啊==
4、回到题目本身，身高高的先放入，按自己的1号位的值就可以确定自己要插入的位置，相同身高1号位大的后插会更简单

[665. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/)
![[picture/665.png]]
```c++
class Solution {
public:
    bool checkPossibility(vector<int>& nums) {
        vector<int> my_nums;
        my_nums.push_back(INT_MIN);
        my_nums.insert(my_nums.end(), nums.begin(), nums.end());
        my_nums.push_back(INT_MAX);
        int count = 0;
        for(int i = 1, sz = my_nums.size(); i < sz - 1; i++){
            if(my_nums[i] > my_nums[i+1]){
                    count++;
                    if(my_nums[i+1] < my_nums[i-1]){
                        my_nums[i+1] = my_nums[i];
                    }
                    else{
                        my_nums[i] = my_nums[i-1];
                    }
            }
            if(count == 2){
                return false;
            }
        }
        return true;
    }
};
```
**本题思路**
1、用了防御式编程
2、贪心的题目实在太靠归纳了，规律就是当my_nums[i] > my_nums[i+1]就进入，但更改的值还需要讨论，讨论的就是my_nums[i+1] < my_nums[i-1]，后一位和前一位的大小比较

# 玩转双指针
双指针主要用于遍历数组，两个指针指向不同元素
- 两个指针指向同一数组，遍历方向相同且不会相交，称为==滑动窗口==，经常用于区间搜素
- 两个指针指向同一数组，遍历方向相反，则可以用来搜索，==常常需要排序==
---
**指针与常量**
```c++
int x;
int *p1 = &x; //指针可以被修改，值也可以被修改
const int *p2 = &x; //指针可以被修改，值不可以被修改
int *const p3 = &x; //指针不可以被修改
const int *const p4; //指针和值都不可以被修改
```
**指针函数与函数指针**
```c++
//返回类型是指针的函数
int* addition(int a, int b){
	int* sum = new int(a + b);
	return sum;
}

int subtraction(int a, int b){
	return a - b;
}

int operation(int x, int y, int (*func)(int, int)){
	return (*func)(x, y);
}

// minus是函数指针，指向函数的指针 
int (*minus)(int, int) = subtraction;
int* m = addition(1, 2); 
int n = operation(3, *m, minus);
```

## 查找
[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)
![[picture/167.png]]
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;
        while(left < right){
            int sum = numbers[left] + numbers[right];
            if(sum == target){
                break;
            }
            else if(sum < target){
                left++;
            }
            else{
                right--;
            }
        }
        return vector<int>{left+1,right+1};
    }
};
```
**本题思路**：
1、拍好序，两个数，buff叠满，直接双指针就行
2、返回的时候用了C++11的特性，直接返回就行

## 归并
[88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)
![[picture/88.png]]
```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int first = 0;
        int second = 0;
        vector<int> res;
        while(first < m && second < n){
            if(nums1[first] <= nums2[second]){
                res.push_back(nums1[first++]);
            }
            else{
                res.push_back(nums2[second++]);
            }
        }
        while(first < m){
            res.push_back(nums1[first++]);
        }
        while(second < n){
            res.push_back(nums2[second++]);
        }
        nums1 = res;
    }
};
```
**本题思路**
1、归并就用双数组的双指针
2、==用到了++和--的技巧，运行速度会略快==，因为编译器通常能生成inc和dec之类的指令，a = a+1有很多编译器会生成二到三字节的指令

## 快慢指针
[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
![[picture/142.png]]
```c++
class Solution
{
public:
    ListNode *detectCycle(ListNode *head)
    {
        ListNode *slow = head, *fast = head;
        // 判断是否存在环路
        do
        {
            if (!fast || !fast->next)
                return nullptr;
            fast = fast->next->next;
            slow = slow->next;
        } while (fast != slow);
        // 如果存在，查找环路节点
        fast = head;
        while (fast != slow)
        {
            slow = slow->next;
            fast = fast->next;
        }
        return fast;
    }
};
```
**本题思路**
1、快慢指针也是常用双指针方法
2、首先判断出环很简单，一快一慢终会相遇
3、==找起始点==：将环分为三段，环外长度m，环中首次相遇点之前为n，之后为k，根据首个循环有2(m+n) = m + n + k + n ->推出n = k。到这基本明了了，慢指针从相遇点出发和快指针从头出发会交到环起始点

[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
![[picture/76.png]]
```c++
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> chars(128,0);
        vector<bool> isExist(128,false);
        int l = 0, l_min = 0, min_len = s.size()+1, t_size = t.size(), count = 0;
        for(int i = 0; i < t_size; i++){
            chars[t[i]]++;
            isExist[t[i]] = true;
        }
        for(int r = 0, sz = s.size(); r < sz; r++){
            //先r右移
            if(isExist[s[r]]){
                if(--chars[s[r]] >= 0){
                    count++;
                }
                while(count == t_size){
                    if(r - l + 1 < min_len){
                        min_len = r - l + 1;
                        l_min = l;
                    }
                    if(isExist[s[l]] && ++chars[s[l]] > 0){
                        count--;
                    }    
                    l++;
                }
            }
        }
        return min_len > s.size() ? "" : s.substr(l_min, min_len);
    }
};
```
**本题思路**
1、先右滑动，然后左收缩，双指针

## 训练

[633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/)
![[picture/633.png]]
```c++
class Solution {
public:
    bool judgeSquareSum(int c) {
        int l = 0, r = sqrt(c);
        while(l <= r){
            int res = c - r * r;
            if(res == l * l){
                return true;
            }
            else if(res > l * l){
                l++;
            }
            else{
                r--;
            }
        }
        return false;
    }
};
```
**本题思路**
1、直接秒掉，先结果开方做右边
2、转换思路，如果左右都平方然后求和会导致超出int范围，所以转为求左边l来判断

[680. 验证回文串 II](https://leetcode.cn/problems/valid-palindrome-ii/)
![[picture/680.png]]
```c++
class Solution {
public:
    bool validPalindrome(string s) {
        int i = 0, j = s.length() - 1;
        while(i < j){
            if(s.at(i) != s.at(j)){
                return isValid(s, i + 1, j) || isValid(s, i, j - 1);
            }
            i++;
            j--;
        }
        return true;
    }
    bool isValid(string s, int i, int j){
        while(i < j){
            if(s.at(i) != s.at(j)){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
};
```
**本题思路**：
1、相比于普通的回文串题目，相当于有一次试错的机会，左跳过一个或者右跳过一个再调用一次回文判断函数

[524. 通过删除字母匹配到字典里最长单词](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/)
![[picture/524.png]]
```c++
class Solution {
public:
    int s_size = 0;
    string findLongestWord(string s, vector<string>& dictionary) {
        s_size = s.size();
        sort(dictionary.begin(), dictionary.end(), [](const string &a, const string &b){
            if(a.size() != b.size()){
                return a.size() > b.size();
            }
            else{
                return a < b;
            }
        });
        
        for(int i = 0, sz = dictionary.size(); i < sz; i++){
            if(exist(s, dictionary[i])){
                return dictionary[i];
            }
        }
        return "";
    }
    bool exist(string &s, string &target){
        int first = 0;
        int second = 0;
        int t_size = target.size();
        while(first < s_size){
            if(s[first] == target[second]){
                second++;
                if(second == t_size){
                    return true;
                }
            }
            first++;
        }
        return false;
    }
};
```
**本题思路**
1、直接一遍过，有什么好说的，按照题意，长串放前面，同样长的字典序小的放前面
2、然后依次判断是否在所给串中，用到了双指针

## 进阶训练
[340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)
![[picture/340.png]]
```c++
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
		int len = s.size();
		if(len * k == 0) return 0;
		int left = 0, right = 0;
		int ans = 0, kind = 0;
		unordered_map<char,int> windows;
		for(int right = 0; right < n; right++){ //向右滑动
			if(winsows[s[right]] == 0){
				++kind;
			}
			windows[s[right]]++;
			while(kind > k){
				windows[s[left]]--; //左边界收缩
				if(windows[s[left] == 0]){
					kind--;
				}
				left++;
			}
			ans = max(ans, right - left + 1)
		}	
		return ans;
	}
};
```
**本题思路**
1、滑动窗口常常搭配哈希表使用

# 居合斩！二分查找
*二分法或折半查找*，O(n)长度的数组，二分查找复杂度为O(logn)

==TIP==
1. 尝试熟练使用一种写法，比如左闭右开(满足C++，python的习惯) 或 左闭右闭(便于处理边界)
2. 思考区间只剩下一个或两个数，自己的写法是否会死循环，无法跳出需要更换写法

## 求开方
[69. x 的平方根](https://leetcode.cn/problems/sqrtx/)
```c++
class Solution {
public:
    int mySqrt(int x) {
        if(x == 0) return x;
        int l = 1, r = x, mid, tmp;
        while(l <= r){
            mid = l + (r - l) / 2; 
            tmp = x / mid;
            if(tmp == mid){
                return mid;
            }
            else if(tmp > mid){
                l = mid + 1;
            }
            else{
                r = mid - 1;
            }
        }
        return r;
    }
};
```
**本题思路**
1、0排除，1到x进行二分，tmp需要运用除法，防止溢出(==这个挺常见的了==)
2、**补充更快算法**：==牛顿迭代法==，公式为：Xn+1 = Xn - f(Xn) / f‘(Xn)，$$ f(x) =  x^2 - a = 0 $$
所以迭代公式 $$ x_{n+1} = (x_n + a/x_n)/2 $$
```c++
int mySqrt(int a){
	long x = a;
	while(x * x > a){
		x = (x + a / x) / 2;
	}
	return x;
}
```
![[picture/牛顿迭代公式.png]]
## 查找区间
[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        int mid = 0;
        while(l <= r){
            mid = l + (r - l) / 2;
            if(nums[mid] == target){
                l = mid;
                r = mid;
                while(l > 0 && nums[l - 1] == target){
                    l--;
                }
                while(r < nums.size() - 1 && nums[r + 1] == target){
                    r++;
                }
                return vector<int>{l, r};
            }
            else if(nums[mid] > target){
                r = mid - 1;
            }
            else{
                l = mid + 1;
            }
        }
        return vector<int>{-1, -1};
    }
};
```
**本题思路**
1、二分 ，如果能找到，再左右扩展，没找到返回默认值
2、**补充知识**:可以自己写c++中的lower_bound和upper_bound
```c++
int lower_bound(vector<int> &nums, int target)
{
    int l = 0, r = nums.size(), mid;
    while (l < r)
    {
        mid = (l + r) / 2;
        if (nums[mid] >= target) //多个等号，说明尽量右边界动
        {
            r = mid;
        }
        else
        {
            l = mid + 1;
        }
    }
    return l;
}


int upper_bound(vector<int> &nums, int target)
{
    int l = 0, r = nums.size(), mid;
    while (l < r)
    {
        mid = (l + r) / 2;
        if (nums[mid] > target) //尽量右边界少动
        {
            r = mid;
        }
        else
        {
            l = mid + 1;
        }
    }
    return l;
}
```

## 旋转数组查找数字
[81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)
```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left <= right)
        {
            //处理重复数字
            while(left < right && nums[left] == nums[left+1]) left++;
            while(left < right && nums[right] == nums[right-1]) right--;
            int mid = left + (right - left)/2;
            if(nums[mid] == target)
            {
                return true;
            }
            if(nums[mid] >= nums[left])
            {
                if(target >= nums[left] && target <= nums[mid])
                {
                    right = mid - 1;
                }
                else
                {
                    left = mid + 1;
                }
            }
            else
            {
                if(target >= nums[mid] && target <= nums[right])
                {
                    left = mid +1;
                }
                else
                {
                    right = mid - 1;
                }
            }
        }
        return false;
    }
};
```
**本题思路**：
1、先判断是在递增序列上还是在已经经历过下坠
2.、也进行了去重

## 训练
[154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)
```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        int mid = 0;
        while(l < r){
            mid = (l + r) / 2;
            if(nums[mid] > nums[r]){
                l = mid + 1;
            }
            else if(nums[mid] < nums[r]){
                r = mid;
            }
            else{
                r--;
            }
        }
        return nums[l];
    }
};
```
1、二分法不要刻意的去记，而是找准判断条件，适时不漏的左右指针收缩

[540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)
```c++
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        int mid = 0;
        while(l < r){
            mid = l + (r - l) / 2;
            if(nums[mid] == nums[mid ^ 1]){
                l = mid + 1;
            }
            else{
                r = mid;
            }
        }
        return nums[l];
    }
};
```
**本题思路**：
1、还是没归纳出规律，其实二分条件就是mid与其对应的位置是否相等
==补充点：==
- 如果 mid 是偶数，则比较 nums[mid]和 nums[mid+1]是否相等；
- 如果 mid 是奇数，则比较 nums[mid]和 nums[mid-1]是否相等；
- **TIP：都可以用mid异或1来获得需要比较的位置**