# 题目分类
![[picture/题型思维导图.png]]
三阶段：
1、算法
2、数学
3、数据结构

# 最易懂的贪心算法

==核心思想：每次操作都是局部最优的，从而使最后得到的结果是全局最优，局部结果互不相关时局部最优策略同样是全局最优==

## 分配问题

![[picture/455.png]]
[455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)
```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
            sort(g.begin(),g.end());
            sort(s.begin(),s.end());
            int childIndex = 0, cookieIndex = 0;
            int childCount = g.size(), cookieCount = s.size();
            while(childIndex < childCount && cookieIndex < cookieCount){
                if(g[childIndex]<= s[cookieIndex]){
                    childIndex++;
                }
                cookieIndex++;
            }
            return childIndex;
    }
```
**本题思路**：
1、饥饿度越小越容易吃饱，用尽量小的饼干去满足他，满足最终的最优解
> TIP：对数组排序是十分常见的，字符数组和字符串不需要特别区分，"abc"和[‘a’,'b','c']都是连续空间上的有序变量集合

![[picture/135.png]]
[135. 分发糖果](https://leetcode.cn/problems/candy/)
```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        // 从后向前
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] ) {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        // 统计结果
        int result = 0;
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
        return result;
    }
};
```
**本题思路**：
1、分配任务大多用贪心是可以很好解决的
2、左右开始各遍历一遍，左到右时直接比前一个加一，右到左时比后一个加一的值和当前已经赋值的最大值
3、最后所有值相加就行