# 2022年9月刷题报告

## 9月1日：

### 数组的最大公因数排序H

[1998. 数组的最大公因数排序 - 力扣（LeetCode）](https://leetcode.cn/problems/gcd-sort-of-an-array/)

==并查集==

```c++
const int N = 3e5 + 10;

class Solution {
    private:
    int p[N];
public:
    //查
    int find(int x)
    {
        if(x != p[x])
        {
            p[x] = find(p[x]);
        }
        return p[x];
    }
    //并
    void merge(int a, int b)
    {
        int x = find(a), y = find(b);
        if(x == y) 
        {
            return;
        }
        p[x] = y;
     }
     //以上两个函数就是标准的并查集应用
    bool gcdSort(vector<int>& nums)
    {
        vector<int> nums1 = nums;
        for(int i = 1; i < N; i++)
        {
            p[i] = i;
        }
        //分解质因数
        for(auto c:nums)
        {
            int k = c;
            for(int i = 2; i <= c / i; i++)
            {
                bool flag = false;
                while(c % i == 0)
                {
                    c /= i,flag = true;
                }
                if(flag)
                {
                    merge(k,i);
                }
            }
            if(c > 1)
            merge(k,c);
        }
         sort(nums1.begin(),nums1.end());
            for(int i = 0; i < nums1.size();i++) 
            {
                if(find(nums[i]) != find(nums1[i]))
                return false;
            }         
            return true;
    }
};
```

首先介绍并查集：

**并查集**：==能够快速判断两个数据是否属于具有同一性质的集合和将两个数据并入该集合==

**并查集具体学习**：

😎这篇文章相当生动形象😎

 [【算法与数据结构】—— 并查集_酱懵静的博客-CSDN博客_并查集](https://blog.csdn.net/the_ZED/article/details/105126583?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166199407316780357245509%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166199407316780357245509&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105126583-null-null.142^v44^pc_rank_34_default_2&utm_term=%E5%B9%B6%E6%9F%A5%E9%9B%86&spm=1018.2226.3001.4187)

**本题思路**：

1、构建并查集（三要素：储存上一个数的数组，find()，merge()）

2、循环数组中的数，如果判断出有最大公因数，三个数都需归入并查集(因为三个能互相交换位置)

3、直接将原数组数组排序

==4、(此处需要好好理解)==：判断排序前后位于同一index的数是否在同一并查集链中(也就是最终boss是否相同)

举例说明：比如 7，3，21变为3，7，21（7与21能交换，3与21能交换等于3和7能交换），这三个其实并到同一并查集链中了，循环判断后会得到true

### 整数反转E

[7. 整数反转 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-integer/)

==溢出，运算==

```c++
class Solution {
public:
    int reverse(int x) {
        long tmp = 0;//这里要用long
        while(x != 0)
        {
            tmp = tmp * 10 + x % 10;
            x = x / 10;
        }
        return (int)tmp == tmp  ? (int)tmp : 0;
    }
};
```

**题目重点**：如果反转后整数超过 32 位的有符号整数的范围 ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

**本题思路**：

1、反转（不多说，简单题）

2、溢出捕获（很巧妙的强转int）

## 9月2日：

### 盛最多水的容器M

[11.盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

==双指针==

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int ans = 0;
        while(left != right)
        {
            ans = max(ans, (right-left)*min(height[left], height[right]));
            height[left] > height[right] ? right-- : left++;//双指针核心
        }
        return ans;
    }
};
```

**题目重点**：下标为横轴，数组储存的值为竖轴，面积为横竖乘积——不理解进leetcode官网看

**双指针详解**：两个从数组首位开始向中间移动，结束条件一般为两个指针碰面，核心是==左右指针何时移动(什么时候动左，什么时候动右)==

**本题思路**：

1、用双指针方法，通过读题得到哪一边高，哪一边暂时按兵不动(这样得到最大值的机会更大，因为移动左右对横轴的影响一致)

2、遇见更大的面积，最大值更新

## 9月3日：

### 罗马数字转整数E

[13. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)

解法一(自研)：

==双指针(==

首先贴一下我第一次做的代码

```c++
class Solution {
public:
    int romanToInt(string s) {
        int left = 0, right = 0;
        int num = 0;
        while(left < s.length())
        {
            int flag = false; 
            if(left == right)
            {
                right++;
            }
            if(s[left] == 'I' && s[right] == 'V')
            {
                num += 4;
                flag = true;
            }
            if(s[left] == 'I' && s[right] == 'X')
            {
                num += 9;
                flag = true;
            }
            if(s[left] == 'X' && s[right] == 'L')
            {
                num += 40;
                flag = true;
                
            }
            if(s[left] == 'X' && s[right] == 'C')
            {
                num += 90;
                flag = true;

            }
            if(s[left] == 'C' && s[right] == 'D')
            {
                num += 400;
                flag = true;

            }
            if(s[left] == 'C' && s[right] == 'M')
            {
                num += 900;
                flag = true;
            }

            if(flag == true)
            {
                left+=2;
                right+=1;
            }
            else
            {
                switch(s[left])
                {
                    case 'I':
                    num += 1;
                    break;
                    case 'V':
                    num += 5;
                    break;
                    case 'X':
                    num += 10;
                    break;
                    case 'L':
                    num += 50;
                    break;
                    case 'C':
                    num += 100;
                    break;
                    case 'D':
                    num += 500;
                    break;
                    case 'M':
                    num += 1000;
                    break;
                    default:
                    break;
                }
                left+=1;
            }
        }
        return num;
    }
};
```

😂虽说看起来比较长，但思路还算清晰，内存和速度都达到了击败90%以上

**本题思路**：

1、两个指针一个走在前面一个紧跟(因为最多只有两个相连的时候有特殊情况)

2、先解决特殊情况，遇到左跳二，右跳一

3、每遇到特殊情况，算左，左跳一

解法二：

==哈希表==

```c++
class Solution {
public:
    int romanToInt(string s) {
        int sum = 0;
        int preNum = getValue(s[0]);
        for(int i = 1;i < s.length(); i++) {
            int num = getValue(s[i]);
            if(preNum < num) {
                sum -= preNum;
            } else {
                sum += preNum;
            }
            preNum = num;
        }
        sum += preNum;
        return sum;
    }
    
    int getValue(char ch) {
        switch(ch) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            default: return 0;
        }
    }
};
```

代码看起来更简洁，但速度和内存使用比我上面的还要高(有点小激动)

**哈希表**：原本此处是要使用哈希表(map)的，但实际使用发现远不如switch语句(此处getvalue函数就是起的哈希表的作用)

**本题思路**：其实读懂题目后并没有这么复杂

1、for循环，当前字符比后一位字符代表的数小，减去当前字符代表数，否则加上

2、getValue函数充当哈希表作用(==似乎小量的数，哈希表并不能很高效啊==)

## 9月4日：

### 三数之和M

[15. 三数之和](https://leetcode.cn/problems/3sum/)

==双指针和排序==

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        //数组小于三直接返回
        if(nums.size()<3) return ans;
        sort(nums.begin(), nums.end());
        // 排序后首位大于0直接返回
        if(nums[0]>0) return ans;
        int i = 0;
        while(i<nums.size()){
            if(nums[i]>0) break;        // 检测的首位提前终止循环
            int left = i+1, right = nums.size()-1;
            while(left< right){
               
                // 转换为long long避免加法过程中溢出,很严谨
                long long y = static_cast<long long>(nums[i]);
                long long x = static_cast<long long>(nums[left]);
                long long z = static_cast<long long>(nums[right]);
                if(x + y + z > 0)//偏大右左移
                    right--;
                else if(x + y + z < 0)//偏小左右移
                    left++;
                else{
                    ans.push_back({nums[i], nums[left], nums[right]});
                    // 相同的left和right不应该再次出现，因此跳过
                    while(left<right&&nums[left]==nums[left+1])
                        left++;
                    while(left<right&&nums[right] == nums[right-1])
                        right--;
                    left++;
                    right--;
                }
            }
            // 避免nums[i]作为第一个数重复出现
            while(i+1<nums.size()&&nums[i] == nums[i+1])
                i++;
            i++;
        }
        return ans;
    }
};
```

**双指针**：这个真的是相当常用了啊，虽说有三个数，还是可以转变为保证一个不动，剩下两个动(==控制变量法==，我自己做的时候就是三个都在动，导致逻辑极其混乱😥😥**吸取教训**)

**本题思路**

1、排序（排序为什么是神，它是很多题目的第一步）

2、最外层循环是左指针，小于数组长度就可以继续（但其实对应的数大于0就可以提前结束循环）

**3、中指针从左指针的下一位出发，右指针从数组末尾出发，判断三数之和，小于0中指针右移，大于0右指针左移，等于0入列（==本质是控制左指针不变，中和右进行标准双指针操作==）**

4、为了防止重复，三个while循环对三个指针进行了重复数快进到不同数

## 9月5日：

### 最接近的三数之和M

[16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)

==双指针==

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int min = INT_MAX;
        int temp = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            int j = i + 1,k = nums.size() - 1;
            while(j < k)
            {
                int sum = nums[i] + nums[j] + nums[k];
                if(abs(sum - target) < min)
                {
                    temp = sum;
                    min = abs(sum - target);
                }
                if(sum < target)
                {
                    while(j < k && nums[j+1] == nums[j])
                    {
                        j++;
                    }
                    j++;
                }
                else if(sum > target)
                {
                    while(j < k && nums[k-1] == nums[k])
                    {
                        k--;
                    }
                    k--;
                }
                else
                {
                    return sum;
                }
            }
            while( i+1 < nums.size() && nums[i+1] == nums[i])
            {
                i++;
            }
        }
        return temp;
    }
};
```

**本题思路**：

1、和上一题类似，但去重快进会使得程序更慢，可能leetcode中的示例没有太多的重复数字的示例，但还是把while加进去吧，更加完善

2、最关键的还是两点：==左右一般不同时移动，一般需要判断哪边移动==，==边界尤为重要，防止漏和超==

### 电话号码的字母组合M

[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

==DFS+哈希表==

```c++
class Solution {
public:
     void func(vector<string> &res,string str,string& digits,string map[], int k)
        {
            if(str.size() == digits.size())
            {
                res.push_back(str);
                return;
            }
            string tmp = map[digits[k] - '0'];
            for(char w : tmp)
            {
                str += w;
                func(res,str,digits,map,k+1);
                str.pop_back();//查过的一定要记得pop出来
            }
            return;
        }
    vector<string> letterCombinations(string digits) {
        string map[10] ={
            "",
            "",
            "abc",
            "def",
            "ghi",
            "jkl",
            "mno",
            "pqrs",
            "tuv",
            "wxyz"
        };

            vector<string> res;
            if(digits == "")
            {
                return res;
            }
            func(res, "", digits, map, 0);
            return res;
    }
};
```

**本题思路：**

1、构建哈希表，数字对应字符串

2、空则直接返回，其余进行DFS

3、DFS，出口就是数字串和字符串长度相同，其余则继续向下搜索

## 9月6日：

### 四数之和M

[18. 四数之和](https://leetcode.cn/problems/4sum/)

==双指针==

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        if (nums.size() < 4)
        {
            return result;
        }
        sort(nums.begin(), nums.end());
        int length = nums.size();
        int i = 0, j = 0, k = 0, l = 0;
        for (i = 0; i < length - 3; i++)
        {
            //排特殊情况
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            if ((long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }
            if ((long)nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                continue;
            }
            for (j = i + 1; j < length - 2; j++)
            {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                if ((long)nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                if ((long)nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }
                k = j + 1, l = length - 1;
                while (k < l)
                {
                    int sum = nums[i] + nums[j] + nums[k] + nums[l];
                    if (sum == target)
                    {
                        result.push_back({ nums[i], nums[j], nums[k], nums[l] });
                        while (k < l && nums[l] == nums[l - 1])
                        {
                            l--;
                        }
                        l--;
                        while (k < l && nums[k] == nums[k + 1])
                        {
                            k++;
                        }
                        k++;
                    }
                    else if (sum > target)
                    {
                        l--;
                    }
                    else
                    {
                        k++;
                    }
                }
            }
        }
        return result;
    }
};
```

**本题思路**：

1、和三数之和类似，只不过多了一层循环(怎么不来个五数之和😡😡)

2、最左边两个指针循环，后面两个指针进行双指针操作==值得一提的是，因为多了一层循环，速度会慢很多，所以拼尽全力的减少不可能的组合进入后续语句(比如最前面四个的和都大于target等)==，这也是之后做题所需要的随机应变

## 9月7日：

###  删除链表的倒数第 N 个结点M

==双指针==

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *left = head, *right = head;
        ListNode* pre_left = left;
        for(int i = 0; i < n; i++)
        {
            right = right->next;
        }
        while(right != nullptr)
        {
            pre_left = left;
            right = right->next;
            left = left->next;
        }
        if(left == head)//左等于头，找到的被删是头结点
        {
            return head->next;
        }
        pre_left->next = left->next;
        return head;
    }
};
```

**本题思路：**

1、右指针比左指针先走n个结点，当右指针指到空的时候，左指针指的就是需要删除的结点

2、删除结点需要注意的是，及时记录被删结点上一个结点

3、特殊情况就是被删元素就是头结点(==注意leetcode的链表的题不含头结点，也就是头指针指的结点就是有数据的==)

## 9月8日：

### 有效的括号E

==栈和哈希表==

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```c++
class Solution {
public:
    bool isValid(string s) {
        int n = s.size();
        if (n % 2 == 1) {
            return false;
        }

        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        stack<char> stk;
        for (char ch: s) {
            if (pairs.count(ch)) {
                if (stk.empty() || stk.top() != pairs[ch]) {
                    return false;
                }
                stk.pop();
            }
            else {
                stk.push(ch);
            }
        }
        return stk.empty();
    }
};
```

**本题思路**

1、首先奇数直接返回错

2、括号对应使用哈希表

3、注意题意，必须紧靠的时候才能push,{[]}—是，([})—不是(==我开始理解错了😂==)

4、最后如果栈全push出来，就说明成功匹配了

## 9月9日：

### 合并两个有序链表E

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

==递归==

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
       if(l1 == nullptr){
           return l2;
       }
       else if(l2 == nullptr){
           return l1;
       }
       else if(l1->val < l2->val){
           l1->next = mergeTwoLists(l1->next,l2);
           return l1;
       }
       else{
           l2->next = mergeTwoLists(l1, l2->next);
           return l2;
       }
    }
};
```

递归：递归真的是神奇而又神圣，能将题目漂亮的解决

**本题思路**

1、两个递归开关，如果一条链空了，则返回另一条链

2、如果对应的值小一点，说明可以做头部了，对后结点和另一条链递归（==递归真的重要啊，一定要花更多时间，不论长短都遵循某一个规律，就可以使用递归了==）

## 9月10日：

### 括号生成M

[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

==DFS+减枝==

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        int stringSize = 2 * n;
        vector<string> result;
        string tmp = "";
        Getvalidparentheses(tmp, stringSize, 0, 0, result);
        for (int i = 0; i < result.size(); i++)
        {
            cout << result[i] << endl;
        }
        return result;
    }

    void Getvalidparentheses(string str, int strSize, int leftNum, int rightNum, vector<string>& result)
    {
        if (leftNum + rightNum > strSize){//总数超过
            return;
        }
        if (leftNum > strSize / 2 || rightNum > strSize / 2){//任意一个超过
            return;
        }
        if (leftNum < rightNum){//左小于右
            return;
        }
        if (str.size() == strSize){//递归出口，字符长度达标
            result.push_back(str);
            return;
        }
        string tmp = str;
        Getvalidparentheses(str += '(', strSize, leftNum + 1, rightNum, result);
        str = tmp;//string没有-=符号，只能用tmp代替-=效果了
        Getvalidparentheses(str += ')', strSize, leftNum, rightNum + 1, result);
    }

};
```

**本题思路:**这题很快就解出来了，有点爽😜

1、运用DFS，不断的往后递归左括号或右括号

2、注意减枝和递归出口

## 9月11日：

### 合并K个升序链表D

[23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

==分治和递归==

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty())
        {
            return nullptr;
        }
        if(lists.size() == 1){
            return lists[0];
        }
        if(lists.size() == 2){
            return mergeTwoLists(lists[0], lists[1]);
        }
        int mid = lists.size()/2;
        vector<ListNode*>left(mid);
        for(int i = 0; i <mid; i++)
        {
            left[i] = lists[i];
        }

        vector<ListNode*> right(lists.size() - mid);
        for(int i = mid,j = 0; i <lists.size();i++,j++)
        {
            right[j] = lists[i];
        }

        return mergeTwoLists(mergeKLists(left),mergeKLists(right));
    }

    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
       if(l1 == nullptr){
           return l2;
       }
       else if(l2 == nullptr){
           return l1;
       }
       else if(l1->val < l2->val){
           l1->next = mergeTwoLists(l1->next,l2);
           return l1;
       }
       else{
           l2->next = mergeTwoLists(l1, l2->next);
           return l2;
       }
    }
};
```

**分治思想：**将长度为k的分为k/2，k/4、、、直到细分的最小的单位，再合并

**本题思路：**

1、两条链表合并的函数模块(其实这题就是21题的加强版)

**2、分治思想，将多条链表细分，两两一组，最终再收上来成一条链**

### 两两交换链表中的节点M

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

==链表的增删改查==

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == nullptr || head->next == nullptr){
            return head;
        }
        ListNode* result,tmp;
        result = &tmp;
        ListNode *left, *mid, *right;
        result->next = head;
        left = result, mid = result->next, right = result->next->next;
        do{
            ListNode* tmp_ptr;
            mid->next = right->next;
            left->next = right;
            right->next = mid;
            tmp_ptr = mid;
            mid = right;
            right = tmp_ptr;
            left = left->next->next;
            mid = left->next ? left->next : nullptr;
            right = mid ? mid->next : nullptr;
        }while(mid && right);
        return result->next;
    }
};
```

**本题思路**：

1、就按题意一步步走就行了，经典双指针(但是自己做到击败百分之百还是有一点爽)

## 9月12日：

### K 个一组翻转链表D

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

==链表的增删改查==

```c++
class Solution {
public:
    // 翻转一个子链表，并且返回新的头与尾
    pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {
        ListNode* prev = tail->next;
        ListNode* p = head;
        while (prev != tail) {
            ListNode* nex = p->next;
            p->next = prev;
            prev = p;
            p = nex;
        }
        return {tail, head};
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* hair = new ListNode(0);
        hair->next = head;
        ListNode* pre = hair;

        while (head) {
            ListNode* tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail->next;
                if (!tail) {
                    return hair->next;
                }
            }
            ListNode* nex = tail->next;
            // 这里是 C++17 的写法，也可以写成
            // pair<ListNode*, ListNode*> result = myReverse(head, tail);
            // head = result.first;
            // tail = result.second;
            tie(head, tail) = myReverse(head, tail);
            // 把子链表重新接回原链表
            pre->next = head;
            tail->next = nex;
            pre = tail;
            head = tail->next;
        }

        return hair->next;
    }
};
```

**本题思路**：

1、写好链表翻转函数，给头尾，翻转后返回头尾==（重点是掌握链表翻转函数）==

2、接下来就k个一组进入函数，出来后再接上就行

## 9月13日：

### 删除有序数组中的重复项E

[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

==双指针==

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 1) return 1;
        int left = 1, right = 1;
        while(right < nums.size())
        {
            if(nums[left] > nums[left-1]){
                left++;
            }
            else{
                if(nums[right] > nums[left-1]){
                    nums[left] = nums[right];
                    left++;
                }
            }
            right++;
        }
        return left;
    }
};
```

**本题思路**：第一次写出这么短小精悍的代码，各击败百分之九十以上

1、左指针指向等待被替换的位置，那么左指针前一位是排好序的数组的最大值

2、右指针只需要不断往后找，找到比当前最大值大的。直接赋值就行了

### 移除元素E

[27. 移除元素](https://leetcode.cn/problems/remove-element/)

```c++
class Solution {
public:
    void swap(int &a, int &b){
        int tmp = a;
        a = b;
        b = tmp;
    }
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = 0;
        while(right < nums.size()){
            if(nums[left] != val){
                left++;
            }
            else{
                if(nums[right] != val){
                    swap(nums[left],nums[right]);
                    left++;
                }
            }
            right++;
        }
        return left;
    }
};
```

**本题思路**：==和26题思想基本一致，只不过换成了交换和改了判断条件==

## 9月14日：

### 找出字符串中第一个匹配项的下标M

[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

==双指针==

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        for(int i = 0; i < haystack.size(); i++)
        {
            for(int j = 0; j < needle.size();j++)
            {
                if(haystack[i+j] != needle[j])
                {
                    break;
                }
                if(i + j > haystack.size())
                {
                    return -1;
                }
                if(j == needle.size()-1)
                {
                    return i;
                }
            }
        }
        return -1;
    }
};
```

**本题思路**：这是朴素算法，对于这一题能够很好解决==可以去加深KMP算法==

1、总循环是主串对比的起始下标，内层循环是对比串的下标

2、有一个对比不上，i后移一位，i后面的长度不够，返回查找失败，全长匹配，返回对应的i

### 两数相除M

[29. 两数相除](https://leetcode.cn/problems/divide-two-integers/)

==递归，位移操作==

```c++
class Solution {
public:
    long div(long a, long b){
        if(a < b) return 0;
        long count = 1;
        long tb = b;
        while(tb+tb <= a){
            count += count;
            tb+=tb;
        }
        return count + div(a-tb,b);
    }
    int divide(int dividend, int divisor) {
        if(dividend == 0) return 0;
        if(divisor == 1) return dividend;
        if(divisor == -1){
            if(dividend == INT_MIN) return INT_MAX;
            return -dividend;
        }
        int sign;
        long a = dividend, b = divisor;
        sign = (a > 0 && b < 0) || (a < 0 && b > 0) ? -1 : 1;
        a = a > 0 ? a : -a;
        b = b > 0 ? b : -b;
        long res = div(a,b);
        if(sign > 0) return res > INT_MAX ? INT_MAX : res;
        return -res;
    }
};
```

**本题思路**：又是摘取的一个大佬的做法

精髓是递归函数：（比如）60/8 = (60-32)/8 + 4 = (60-32-16)/8 + 2 + 4 = 1 + 2 + 4 = 7

1、递归里面只能用加号代替乘号

2、特殊情况先返回，剩下的推出结果符号，再都取绝对值进入递归

## 9月15日：

### 串联所有单词的子串H

==滑动窗口、哈希表==

[30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        if(words.empty()) return {};
        unordered_map<string,int> wordmap,smap;
        for(string word:words) wordmap[word]++;
        int wordlen = words[0].size();
        int wordnum = words.size();
        vector<int> ans;
        for(int k=0;k<wordlen;k++){
            int i=k,j=k;
            while(i<s.size()-wordnum*wordlen+1){
                while(j<i+wordnum*wordlen){
                    string temp = s.substr(j,wordlen);
                    smap[temp]++;
                    j+=wordlen;
                    if(wordmap[temp]==0){//情况二，有words中不存在的单词
                        i=j;//对i加速
                        smap.clear();
                        break;
                    }
                    else if(smap[temp]>wordmap[temp]){//情况三，子串中temp数量超了
                        while(smap[temp]>wordmap[temp]){
                            smap[s.substr(i,wordlen)]--;
                            i+=wordlen;//对i加速
                        }
                        break;
                    }                   
                }
                //正确匹配，由于情况二和三都对i加速了，不可能满足此条件
                if(j==i+wordlen*wordnum){
                    ans.push_back(i);
                    smap[s.substr(i,wordlen)]--;
                    i+=wordlen;//i正常前进
                }
            }
            smap.clear();
        }
        return ans;
    }
};
```

**本题思路**：

1、主要是运用到了哈希表，当判断子单词，只需要对比哈希表就行，看看是否和预先存的哈希表的数量一致

2、滑动窗口的情况较多，具体参考[详细通俗的思路分析，多解法 - 串联所有单词的子串 - 力扣（LeetCode）](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/)

## 9月16日(补)：

### 下一个排列M

==双指针==

[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

```c++
class Solution {
public:
    void swap(int& a, int& b)
    {
        int tmp = a;
        a = b;
        b = tmp;
    }
    void nextPermutation(vector<int>& nums) {
        int length = nums.size();
        int i = length - 2, j = length - 1, k = length -1;

        while(i>=0 && nums[i] >= nums[j])
        {
            i--;
            j--;
        }
        if(i >= 0)
        {
            while(nums[k] <= nums[i])
            {
                k--;
            }
            swap(nums[k],nums[i]);
        }
        for(i = j, j = length -1; i < j; i++,j--);
        {
            swap(nums[j],nums[i]);
        }
    }
};
```

**本题思路**：

因leetcode解答十分强大，且仅针对此题，不再自编思路

[下一个排列算法详解：思路+推导+步骤，看不懂算我输！ - 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/)

## 9月17日：

### 搜索旋转排序数组M

==二分查找==

[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```c++
class Solution {
public:
    //旋转二分查找
    int search(vector<int>& nums, int target) {
    int lo = 0, hi = nums.size() - 1, mid = 0;
    while (lo <= hi) {
        mid = lo + (hi - lo) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        // 先根据 nums[mid] 与 nums[lo] 的关系判断 mid 是在左段还是右段 
        if (nums[mid] >= nums[lo]) {
            // 再判断 target 是在 mid 的左边还是右边，从而调整左右边界 lo 和 hi
            if (target >= nums[lo] && target < nums[mid]) {
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }
        else {
            if (target > nums[mid] && target <= nums[hi]) {
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
    }
    return -1;
    }
};
```

**本题思路：**

1、因为不是排好序的数组，但总体还是有一个序，所以我们只需要更改二分查找的判断分支

2、我们进行target和中间数比较的时候，需要先对我们要查找的区间进行判断

## 9月18日(补)：

### 在排序数组中查找元素的第一个和最后一个位置M

==二分查找==

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result(2, -1);
        int left = 0, right = nums.size() - 1;
        int tmp_left = left, tmp_right = right;
        int mid = 0;
        while (left <= right) {
            //tmp_left = nums[left] < target ? left : tmp_left;
            //tmp_right = nums[right] > target ? right : tmp_right;
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            }
            else if (nums[mid] > target) {
                right = mid - 1;
            }
            else {
                if (mid == 0 || nums[mid - 1] < nums[mid]) {
                    result[0] = mid;
                    break;
                }
                right = mid - 1;
            }
        }
        while (tmp_left <= tmp_right) {
            mid = tmp_left + (tmp_right - tmp_left) / 2;
            if (nums[mid] < target) {
                tmp_left = mid + 1;
            }
            else if (nums[mid] > target) {
                tmp_right = mid - 1;
            }
            else {
                if (mid == nums.size() - 1 || nums[mid + 1] > nums[mid])
                {
                    if (result[0] != -1) result[1] = mid;
                    break;
                }
                tmp_left = mid + 1;
            }
        }
        return result;
    }
};
```

**本题思路**

1、其实就是基本的二分查找，从cookbook里得知，二分查找还可以找到第一个小于target，第一个大于target等等，只需要在target == nums[mid]的分支里加入一句判断语句

2、这里需要找两次，一左一右，引入tmp_left,tmp_right是为了用第一次查找的信息，此题加不加都是击败90per以上

## 9月19日：

### 搜索插入位置E

==二分查找==

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int l=0,r=n-1;
        while(l<=r){
            int mid=l+(r-l)/2;
            if(nums[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
};
```

**本题思路**：

1、就是一个二分查找，最后返回left就是结果

## 9月20日：

### 有效的数独M

==哈希表，数组的遍历==

[36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

```c++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        for(int i = 0 ; i < board.size(); i++){
            bool square[9] = {false};
            bool row[9] = {false};
            bool list[9] = {false};
            for(int j = 0; j <board[0].size(); j++){
                int num = board[i][j] - '1';//第i行
                if(num != '.' - '1'){
                    if(row[num]){
                        return false;
                    }
                    else{
                        row[num] = true;
                    }
                }
                num = board[j][i] -'1';//第i列
                if(num != '.' - '1'){
                    if(list[num]){
                        return false;
                    }
                    else{
                        list[num] = true;
                    }
                }
                num = board[i/3*3+j/3][i%3*3+j%3]-'1';//第i个方格
                if(num != '.' - '1'){
                    if(square[num]){
                        return false;
                    }
                    else{
                        square[num] = true;
                    }
                }
            }
        }
        return true;
    }
};
```

 **本题思路**

1、题目条件有三个，行、列、方格不重复，那么我们可以进行九次判断，每次根据i，j表示出对应的格，用三个哈希表，存对应的数字是否已经存在过了

2、使用ij推方格的时候要了点时间，其他的还好，没有就存，有就直接返回false

## 9月21日：

### 解数独H

==回溯法，哈希表==

[37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

```c++
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        if (board.size() != 9 || board[0].size() != 9) return;
        bool row[9][9]= {false}, col[9][9] = {false}, box[9][9] = {false};
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') continue;
                int num = board[i][j] - '1', k = (i / 3) * 3 + j / 3;
                row[i][num] = col[j][num] = box[k][num] = true;
            }
        }
        solveSudokuHelper(board, 0, row, col, box);
    }

    bool solveSudokuHelper(vector<vector<char>>& board, int n, bool row[][9], bool col[][9], bool box[][9]) {
        if (n == 81) return true;
        int i = n / 9, j = n % 9;
        if (board[i][j] != '.') return solveSudokuHelper(board, n + 1, row, col, box);

        int k = (i / 3) * 3 + j / 3;
        for (int num = 0; num < 9; num++) {
            if (row[i][num] || col[j][num] || box[k][num]) continue;
            board[i][j] = (char) (num + '1');
            row[i][num] = col[j][num] = box[k][num] = true;
            if (solveSudokuHelper(board, n + 1, row, col, box)) return true;
            row[i][num] = col[j][num] = box[k][num] = false;
        }
        board[i][j] = '.';
        return false;
    }
};
```

**本题思路**：

1、首先三个bool数组，表示的是九次判断分别的横纵方的数字存在情况

2、回溯法，直到81才完成，其实就是一个标准的回溯解法

## 9月22日：

==递归==

### 外观数列M

[38. 外观数列](https://leetcode.cn/problems/count-and-say/)

```c++
class Solution {
public:
    string countAndSay(int n) {
        if(n == 1)return "1";
        string last = countAndSay(n-1);
        string ans = "";
        int count = 1;
        for(int i = 0 ; i < last.size(); i++)
        {
            if(i+1 < last.size() && last[i] == last[i+1])
            {
                count++;
            }
            else
            {
                ans += count + '0';
                ans += last[i];
                count = 1;
            }
        }
        return ans;
    }
};
```

**本题思路**

1、题意其实就是，下一个数字其实是描述上一个数字，很明显的递归的意思

### 组合总和M

==DFS及减枝==

[39. 组合总和](https://leetcode.cn/problems/combination-sum/)

```c++
class Solution {
public:
    void SumDFS(vector<int>& candidates, vector<int>& result, vector<vector<int>>& results, int sum, int target,int begin)
    {
        if(sum > target)
        {
            return;
        }
        else if(sum < target)
        {
            for(int i = begin; i < candidates.size(); i++)
            {
                result.push_back(candidates[i]);
                SumDFS(candidates, result, results, sum + candidates[i],target,i);
                result.pop_back();
            }
        }
        else
        {
            results.push_back(result);
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> results;
        vector<int> result;
        SumDFS(candidates, result, results, 0, target, 0);
        return results;
    }
};
```

**本题思路**：

1、看来DFS我基本能做了，这题使用了基本的DFS算法

2、减枝，当和大于target当然需要结束，还有，函数还传了个begin，可以减少重复，直接从上一个判断的数开始往后判断

### 组合总和 IIM:

==DFS加减枝==

[40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

```c++
class Solution {
public:
    void SumDFS(vector<int>& candidates, vector<int>& result, vector<vector<int>>& results, int sum, int target,int begin)
    {
        if(sum > target)
        {
            return;
        }
        else if(sum < target)
        {
            for(int i = begin; i < candidates.size(); i++)
            {
              	//精髓所在
                if (i > begin && candidates[i] == candidates[i - 1]) {
                continue;
            }
                result.push_back(candidates[i]);
                SumDFS(candidates, result, results, sum + candidates[i],target,i+1);
                result.pop_back();
            }
        }
        else
        {
            results.push_back(result);
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> results;
        vector<int> result;
        sort(candidates.begin(), candidates.end());
        SumDFS(candidates, result, results, 0, target, 0);
        return results;
    }
};
```

**本题思路**：

1、本题基本思想与上一题相似，不同之处在于递归的时候开始参数不能再从自己开始

**2、最重要的为代码块注释的那一句，这题我们其实是提前对数组进行了排序，方便后面的去重，看第一句i > begin可以看出第一个是绝对进得了递归的，后面相等则跳过，试想一下，==相同的数进行并列递归，是不是取第一个数进入就会是包含后面相同数字进入的所有情况的😎重要思想，注意学习😎==**，复习的时候理解不了再回去看看题解吧

[回溯算法 + 剪枝（Java、Python） - 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/)

## 9月23日：

### 缺失的第一个正数H

==原地哈希表==

[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

```c++
class Solution {
public:
    int firstMissingPositive(vector<int> &nums) {
        for (int i = 0; i < nums.size(); i++) {
            while (nums[i] != i + 1) {
                if (nums[i] <= 0 || nums[i] > nums.size() || nums[i] == nums[nums[i] - 1])
                    break;
                // 将nums[i] 放置到对应位置上[1,2,3...]
                int idx = nums[i] - 1;
                nums[i] = nums[idx];
                nums[idx] = idx + 1;
            }
        }
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != (i + 1)) {
                return (i + 1);
            }
        }
        return (nums.size() + 1);
    }
};

```

**本题思路**：这题在时间和空间复杂度的要求下，完全没有思路😫

1、原地哈希表的意思是，不开辟新的空间，让原数组的下标当成哈希表的键值对左边

2、此时我们需要先遍历一边数组，把值摆到对应的下标中，之后再进行第二次遍历，当发现下标和值不对应的就返回，假如超过长度都还没发现，就返回数组长度加1

## 9月24日：

### 接雨水H

==动归==

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> left(n,0), right(n,0);
        int sum = 0;
        for(int i = 1; i < n; i++)
        {
            left[i] = max(height[i-1], left[i-1]);
        }
        for(int i = n-2; i >= 0; i--)
        {
            right[i] = max(height[i+1], right[i+1]);
        }
        for(int i = 0; i < n; i++)
        {
            int minHeght = min(left[i], right[i]);
            sum += max(0, minHeght - height[i]);
        }
        return sum;
    }
};
```

动态规划：**通过记住一些子问题的解来节省时间**，就是下一次问题的解，不需要从头开始，而是从上一层问题的解得到

比如这题：

left数组的值有以下意义，我们得到i+1的left值就可以直接用left[i]来简化操作

- 下标 i 左边的柱子
- 最高的高度值

## 9月25日(补)

###  字符串相乘M

==字符串数字的运算==

[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

```c++
class Solution {
public:
    string multiply(string num1, string num2) {
        vector<int> A, B;
        int n = num1.size(), m = num2.size();
        for (int i = n - 1; i >= 0; i -- ) A.push_back(num1[i] - '0'); //反向存贮
        for (int i = m - 1; i >= 0; i -- ) B.push_back(num2[i] - '0');
        vector<int> C(n + m);
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < m; j ++ )
                C[i + j] += A[i] * B[j];
        int t = 0;  //存贮进位
      	//进位循环
        for (int i = 0; i < C.size(); i ++ ) {
            t += C[i];
            C[i] = t % 10;
            t /= 10;
        }
        int k = C.size() - 1;
        while (k > 0 && !C[k]) k -- ;  //去除前导0
        string res;
        while (k >= 0) res += C[k -- ] + '0';  //反转
        return res;
    }
};
```

**本题思路**：

1、字符串数字基本操作就是反向存进整型数组

2、做乘法的时候，可以先不管进位，把乘积在对应位的数据求和

3、得到结果数组后，再进行进位操作(==上面的进位的循环可以记住==)

4、因为我们开结果数组是开最大的，容量可能超标，也就是前面会有0，所以我们要进行去零操作

5、最后反转

这种题的大忌：==真正的将结果算出来，存进整型类型里，但我们知道，字符串可能是很长的，再大的类型都有可能溢出==

## 9月26日：

### 全排列M

==回溯==

[46. 全排列](https://leetcode.cn/problems/permutations/)

```c++
class Solution {
public:
    void backTrack(vector<vector<int>>& results, vector<int>& temp, vector<int>& nums, vector<bool>& isChosen, int i)
    {
        if(temp.size() == nums.size())
        {
            results.push_back(temp);
        }
        for(int i = 0; i < nums.size(); i++)
        {
            if(isChosen[i] == true) continue;
            isChosen[i] = true;
            temp.push_back(nums[i]);
            backTrack(results, temp, nums, isChosen, i);
            isChosen[i] = false;
            temp.pop_back();
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> isChosen(nums.size(), false);
        vector<vector<int>> results;
        vector<int> temp;
        backTrack(results, temp, nums, isChosen, 0);
        return results;
    }
};
```

**本题思路**：回溯算法，不再啰嗦

## 9月27日：

### 全排列 II M

==回溯，去重==

[47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

```c++
class Solution {
public:
    void backTrack(vector<vector<int>>& results, vector<int>& temp, vector<int>& nums, vector<bool>& isChosen)
    {
        if(temp.size() == nums.size())
        {
            results.push_back(temp);
        }
        for(int i = 0; i < nums.size(); i++)
        {
            if(!isChosen[i])
            {
                if(i > 0 && nums[i] == nums[i-1] && !isChosen[i-1]) continue;
            }
            if(isChosen[i] == true) continue;
            isChosen[i] = true;
            temp.push_back(nums[i]);
            backTrack(results, temp, nums, isChosen);
            isChosen[i] = false;
            temp.pop_back();
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<bool> isChosen(nums.size(), false);
        vector<vector<int>> results;
        vector<int> temp;
        backTrack(results, temp, nums, isChosen);
        return results;
    }
};
```

**本题思路**：

1、回溯的基本思想与上一题相同，区别就是有重复，需要去重

**2、去重再次使用了，先排序，通过在所有相同的数字中选一个进行递归达到去重效果**

### 旋转图像M

==数组的翻转==

[48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 1; i < n; i++)
        {
            for(int j = 0; j < i; j++)
            {
                swap(matrix[i][j],matrix[j][i]);
            }
        }
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n / 2; j++)
            {
                swap(matrix[i][j],matrix[i][n-j-1]);
            }
        }
    }
};
```

**本题思路**：

1、旋转转换成进行数组的对称操作，比如对角线，行列翻转

## 9月28日：

### 字母异位词分组M

==哈希表==

[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        map<string,vector<string>> M;
        for(int i=0;i<strs.size();i++){
            string key=strs[i];
            sort(key.begin(),key.end());
            M[key].push_back(strs[i]);
        }
        for(auto ite=M.begin();ite!=M.end();ite++)
            res.push_back(ite->second);
        return res;
    }
};
```

**本题思路**：

1、哈希表简直太强悍了，感觉每个题都可以先往哈希表想一下

2、相同字母组成的不同单词，排序后会得到同一个单词，得到的单词作为键值，对应单词加进哈希表中

### Pow(x, n)

==迭代==

[50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

```c++
class Solution {
public:
    double myPow(double x, int n) {
        double res = 1.0;
        for(int i = n; i != 0; i /= 2.0)
        {
            if(i % 2 != 0) 
            {
                res *= x;
            }
            x *= x; 
        }
        return n > 0 ? res : 1 / res;
    }
};
```

**本题思路**

1、按照n去循环会超时，所以我们要简化，迭代，每次i/2，偶数的时候可以让x自乘，基数就乘以x(其实递归更容易理解)

题解：[[LeetCode\] 50. Pow(x, n) 求x的n次方 - Grandyang - 博客园 (cnblogs.com)](https://www.cnblogs.com/grandyang/p/4383775.html)

## 9月29日：

### N 皇后H

==回溯==

[51. N 皇后](https://leetcode.cn/problems/n-queens/)

```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<bool> isSet(n, false);
        vector<vector<string>> results;
        vector<string> result(n,string(n,'.'));

        backTrack(results, result, isSet,0);
        return results;
    }
    void backTrack(vector<vector<string>>& results, vector<string>& result, vector<bool>& isSet, int row)
    {
        if(row == result.size())
        {
            results.push_back(result);
            return;
        }
        for(int i = 0; i < isSet.size(); i++)
        {
            if(isSet[i] == true) continue;
            int flag = false;
            for(int j = 1; row - j >= 0 && i - j >= 0; j++)
            {
                if(result[row-j][i-j] == 'Q')
                {
                    flag = true;
                    break;
                }
            }
            for(int j = 1; row - j >= 0 && i + j < result.size(); j++)
            {
                if(result[row-j][i+j] == 'Q'){
                    flag = true;
                    break;
                } 
            }
            if(flag == true) continue;
            isSet[i] = true;
            result[row][i] = 'Q';
            backTrack(results, result, isSet,row + 1);
            isSet[i] = false;
            result[row][i] = '.';
        }
    }
};
```

**本题思路**：

1、每次回溯往下走一行，避免行重复

2、isSet数组记录对应列是否已经摆过，避免列重复

3、两个for循环除去斜行(==是斜行，而不是仅仅对角==)重复的情况

### N皇后 IIH

==回溯==

[52. N皇后 II](https://leetcode.cn/problems/n-queens-ii/)

```c++
class Solution {
public:
    int totalNQueens(int n) {
        vector<bool> isSet(n, false);
        int count = 0;
        vector<string> result(n,string(n,'.'));
        backTrack(count, result, isSet,0);
        return count;
    }
    void backTrack(int& count, vector<string>& result, vector<bool>& isSet, int row)
    {
        if(row == result.size())
        {
            count++;
            return;
        }
        for(int i = 0; i < isSet.size(); i++)
        {
            
            if(isSet[i] == true) continue;
            int flag = false;
            for(int j = 1; row - j >= 0 && i - j >= 0; j++)
            {
                if(result[row-j][i-j] == 'Q')
                {
                    flag = true;
                    break;
                }
            }
            for(int j = 1; row - j >= 0 && i + j < result.size(); j++)
            {
                if(result[row-j][i+j] == 'Q'){
                    flag = true;
                    break;
                } 
            }
            if(flag == true) continue;
            isSet[i] = true;
            result[row][i] = 'Q';
            backTrack(count, result, isSet,row + 1);
            isSet[i] = false;
            result[row][i] = '.';
        }
    }
};
```

**本题思路**：

1、与上一题基本一致，改了结果的输出而已

## 9月30日：

### 最大子数组和M

**解法一：**

==动态规划==

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len = nums.size();
        vector<int> dq(len);
        dq[0] = nums[0];
        for(int i = 1; i < len; i++)
        {
            if(dq[i-1] > 0)
            {
                dq[i] = dq[i-1] + nums[i];
            }
            else
            {
                dq[i] = nums[i];
            }
        }
        int res = dq[0];
        for(int i = 1; i < len; i++)
        {
            res = max(dq[i], res);
        }
        return res;
    }
};
```

**本题思路：**

1、本题是首次较为深入的学习动态规划，看得出动规的代码量很少，但其中包含的思考可完全不少，还需要更深入的理解，具体看这题leetcode上写的很好的题解

**解法二**

==分治法==

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len = nums.size();
        if(len == 0) return 0;
        return maxSubArraySum(nums, 0, len-1);
    }

    int maxCrossingArray(vector<int>& nums, int left, int mid, int right)
    {
        int sum = 0;
        int leftSum = INT_MIN;
        for (int i = mid; i >= left; i--) {
            sum += nums[i];
            if (sum > leftSum) {
                leftSum = sum;
            }
        }
        sum = 0;
        int rightSum = INT_MIN;
        // 右半边不包含 nums[mid] 元素，最多可以到什么地方
        // 计算以 mid+1 开始的最大的子数组的和
        for (int i = mid + 1; i <= right; i++) {
            sum += nums[i];
            if (sum > rightSum) {
                rightSum = sum;
            }
        }
        return leftSum + rightSum;
    }
    int maxSubArraySum(vector<int>& nums, int left, int right)
    {
        if(left == right) return nums[left];
        
        int mid = left + (right - left) / 2;
        return max3(maxSubArraySum(nums, left, mid),
        maxSubArraySum(nums, mid+1, right),
        maxCrossingArray(nums,left,mid,right));

    }

    int max3(int a, int b, int c)
    {
        return max(a, max(b, c));
    }
};
```

**本题思路**：

1、每个子问题的最大值只有三种情况，由中间往左延申，由中间往右边延申，包含中间的两个元素往左右同时延申

补：具体的参考下面这篇题解，能学到许多

[经典动态规划问题（理解「无后效性」） - 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)

## 9月刷题总结：

总体来说完成的不错，但还是有十道题左右完全看的别人的优秀思路(可能是题量不够，自我安慰😁)，只能说开了个好头吧，10月开始了，继续坚持吧