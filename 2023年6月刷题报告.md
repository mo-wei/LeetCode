# 2023年6月刷题报告

## 6月1日

### 对链表进行插入排序M

==链表的增删改查==

[147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)
```c++
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode * head_pre = new ListNode();
        ListNode * pre;
        head_pre->next = head;
        while(head != nullptr && head->next != nullptr){
            if(head->val <= head->next->val){
                head = head->next;
                continue;
            }

            pre = head_pre;

            while(pre->next->val < head->next->val) pre = pre->next;

            ListNode* curr = head->next;
            head->next = curr->next;
            curr->next = pre->next;
            pre->next = curr;
        }
        return head_pre->next;
    }
};
```

**本题思路**：
1、外部while，保证不遍历已经排列好的部分
2、内部while，每次找到需要交换结点的前一个，以便于结点的交换


### 排序链表M
[148. 排序链表](https://leetcode.cn/problems/sort-list/)

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return mergeSort(head);
    }
    
    ListNode* mergeSort(ListNode* node) {
        if (!node || !node->next) return node;
        //快慢指针
        ListNode* fast = node;
        ListNode* slow = node;
        ListNode* breakN = node;
        while (fast && fast->next) {
            fast = fast->next->next;
            breakN = slow;
            slow = slow->next;
        }
        breakN->next = nullptr;
        ListNode *l1 = mergeSort(node);
        ListNode *l2 = mergeSort(slow);
        return merge(l1, l2);
    }
    
    ListNode* merge(ListNode* l1, ListNode* l2) {
        //递归到底的情况
        if (l1 == nullptr) return l2;
        if (l2 == nullptr) return l1;
        //分情况递归实现
        if (l1->val <= l2->val) {
            l1->next = merge(l1->next, l2);
            return l1;
        } else {
            l2->next = merge(l2->next, l1);
            return l2;
        }
    }
};
```
**本题思路**：
1、递归三部曲：（1)快慢指针找中点 (2)递归调用mergeSort (3) 合并两个链表